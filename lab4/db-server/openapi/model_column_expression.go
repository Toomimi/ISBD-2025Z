// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * MIMUW ISBD database system
 *
 * This file describes interface between DBMS system and user.
 *
 * API version: 2.1.0
 */

package openapi

import (
	"bytes"
	"encoding/json"
	"fmt"
)

type ColumnExpressionImpl interface {
	IsColumnExpression() bool
}

func (c ColumnReferenceExpression) IsColumnExpression() bool { return true }
func (l Literal) IsColumnExpression() bool                   { return true }
func (f Function) IsColumnExpression() bool                  { return true }
func (b ColumnarBinaryOperation) IsColumnExpression() bool   { return true }
func (u ColumnarUnaryOperation) IsColumnExpression() bool    { return true }

type ColumnExpression struct {
	Expression ColumnExpressionImpl
}

func (c *ColumnExpression) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		return nil
	}

	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	_, hasValue := raw["value"]
	_, hasFunction := raw["functionName"]
	_, hasColumn := raw["columnName"]
	_, hasOperator := raw["operator"]
	_, hasLeft := raw["leftOperand"]
	_, hasOperand := raw["operand"]

	if hasValue {
		var literal Literal
		dec := json.NewDecoder(bytes.NewReader(data))
		dec.DisallowUnknownFields()
		if err := dec.Decode(&literal); err != nil {
			return fmt.Errorf("invalid Literal: %w", err)
		}
		c.Expression = literal
		return nil
	}

	if hasFunction {
		var function Function
		dec := json.NewDecoder(bytes.NewReader(data))
		dec.DisallowUnknownFields()
		if err := dec.Decode(&function); err != nil {
			return fmt.Errorf("invalid Function: %w", err)
		}
		c.Expression = function
		return nil
	}

	if hasColumn {
		var colRef ColumnReferenceExpression
		dec := json.NewDecoder(bytes.NewReader(data))
		dec.DisallowUnknownFields()
		if err := dec.Decode(&colRef); err != nil {
			return fmt.Errorf("invalid ColumnReferenceExpression: %w", err)
		}
		c.Expression = colRef
		return nil
	}

	if hasOperator {
		if hasLeft {
			var binaryOp ColumnarBinaryOperation
			dec := json.NewDecoder(bytes.NewReader(data))
			dec.DisallowUnknownFields()
			if err := dec.Decode(&binaryOp); err != nil {
				return fmt.Errorf("invalid ColumnarBinaryOperation: %w", err)
			}
			c.Expression = binaryOp
			return nil
		}
		if hasOperand {
			var unaryOp ColumnarUnaryOperation
			dec := json.NewDecoder(bytes.NewReader(data))
			dec.DisallowUnknownFields()
			if err := dec.Decode(&unaryOp); err != nil {
				return fmt.Errorf("invalid ColumnarUnaryOperation: %w", err)
			}
			c.Expression = unaryOp
			return nil
		}
		return fmt.Errorf("invalid operator")
	}

	return fmt.Errorf("invalid column expression, cannot determine type")
}

func (c ColumnExpression) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.Expression)
}

func AssertColumnExpressionRequired(obj ColumnExpression) error {
	if obj.Expression == nil {
		return fmt.Errorf("column expression is empty")
	}

	switch e := obj.Expression.(type) {
	case ColumnReferenceExpression:
		return AssertColumnReferenceExpressionRequired(e)
	case Literal:
		return AssertLiteralRequired(e)
	case Function:
		return AssertFunctionRequired(e)
	case ColumnarBinaryOperation:
		return AssertColumnarBinaryOperationRequired(e)
	case ColumnarUnaryOperation:
		return AssertColumnarUnaryOperationRequired(e)
	default:
		return fmt.Errorf("unknown column expression type")
	}
}

// AssertColumnExpressionConstraints checks if the values respects the defined constraints
func AssertColumnExpressionConstraints(obj ColumnExpression) error {
	if obj.Expression == nil {
		return nil
	}

	switch e := obj.Expression.(type) {
	case ColumnReferenceExpression:
		return AssertColumnReferenceExpressionConstraints(e)
	case Literal:
		return AssertLiteralConstraints(e)
	case Function:
		return AssertFunctionConstraints(e)
	case ColumnarBinaryOperation:
		return AssertColumnarBinaryOperationConstraints(e)
	case ColumnarUnaryOperation:
		return AssertColumnarUnaryOperationConstraints(e)
	}
	return nil
}
